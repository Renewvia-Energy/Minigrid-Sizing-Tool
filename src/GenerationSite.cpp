#include <vector>
#include <memory>
#include <functional>
#include "BatteryInverter.cpp"
#include "BatteryBank.cpp"
#include "PVInverter.cpp"
#include "ChargeController.cpp"
#include "DieselGenerator.cpp"

struct GenerationSiteOperationStep {
	double availableACFromPVInverters;
	double availableDCFromCCs;
	double loadWithDxLosses;
	double batterySOCWhStart;
	double batterySOCStart;
	double batterySOCWhEnd;
	double batterySOCEnd;
	double totalSolarToLoad;
	double totalSolarToBattery;
	double totalBatteryToLoad;
	double totalEnergyToLoad;
	double generatorLoad;
	double generatorFuelConsumption;
	double remainingLoad;
	double wastedSolar;
};

class GenerationSite {
	private:
		const std::unique_ptr<BatteryInverter> batteryInverter;
		const std::shared_ptr<BatteryBank> batteryBank;
		const std::vector<std::unique_ptr<PVInverter>> pvInverters;
		const std::vector<std::unique_ptr<ChargeController>> chargeControllers;
		const std::unique_ptr<DieselGenerator> generator;
		const std::function<bool(double, double)> shouldTurnGeneratorOn;	// (soc: number, t: number) => boolean
		const std::function<bool(double, double)> shouldTurnGeneratorOff;	// (soc: number, t: number) => boolean
		const double vac;
		double acBus;

	public:
		/**
		 * All of the equipment at a generation site.
		 *
		 * @param {BatteryInverter} batteryInverter - The total battery inverter.
		 * @param {BatteryBank} batteryBank - The battery bank.
		 * @param {ACCoupledPVGenerationEquipment} pvInverters - All of the PV inverters and their connected solar panels.
		 * @param {DCCoupledPVGenerationEquipment} chargeControllers - All of the charge controllers and their connected solar panels
		 * @param {Generator} generator - The diesel generator
		 * @param {function(soc: number, t: number) => boolean} shouldTurnOnGenerator - A function to decide when to turn the generator on given battery SOC and the current time since commissioning [hr]
		 * @param {function(soc: number, t: number) => boolean} shouldTurnOffGenerator - A function to decide when to turn the generator off given battery SOC and the current time since commissioning [hr]
		 * @param {number} vac - Output AC voltage
		 * @constructor
		 */
		GenerationSite(std::unique_ptr<BatteryInverter> batteryInverter, std::shared_ptr<BatteryBank> batteryBank, std::vector<std::unique_ptr<PVInverter>> pvInverters, std::vector<std::unique_ptr<ChargeController>> chargeControllers, std::unique_ptr<DieselGenerator> generator, std::function<bool(double, double)> shouldTurnOnGenerator, std::function<bool(double, double)> shouldTurnOffGenerator, double vac) : batteryInverter(std::move(batteryInverter)), batteryBank(batteryBank), pvInverters(pvInverters), chargeControllers(chargeControllers), generator(std::move(generator)), shouldTurnGeneratorOn(shouldTurnOnGenerator), shouldTurnGeneratorOff(shouldTurnOffGenerator), vac(vac), acBus(0) {
			batteryInverter->connectBatteryBank(batteryBank);
		}

		/**
		 * Runs the generation site for one unit of time
		 *
		 * @param {number} t - Time since commissioning [hr]
		 * @param {number} dt - The amount of time that passes [hr].
		 * @param {number} dcArrayOutputWhPerWp - From irradiance data [Wh/kWp].
		 * @param {number} load - Total load, including distribution losses [Wh].
		 * @returns {Object} - An object with 13 keys:
		 * - availableACFromPVInverters {number} Energy generated by PV inverters [Wh].
		 * - availableDCFromCCs {number} Energy generated by charge controllers [Wh].
		 * - loadWithDxLosses {number} The load, given as an input parameter [Wh].
		 * - batterySOCWhStart {number} Amount of energy remaining in the battery bank at the start of dt [Wh].
		 * - batterySOCStart {number} SOC of the battery bank at the start of dt.
		 * - batterySOCWhEnd {number} Amount of energy remaining in the battery bank at the end of dt [Wh].
		 * - batterySOCEnd {number} SOC of the battery bank at the end of dt.
		 * - totalSolarToLoad {number} Energy sent from the PV inverters to the load [Wh].
		 * - totalSolarToBattery {number} Energy sent from the PV to the batteries [Wh].
		 * - totalBatteryToLoad {number} Energy sent from the batteries to the load [Wh].
		 * - totalEnergyToLoad {number} Energy sent from the generation site to the load [Wh].
		 * - generatorLoad {number} Energy supplied by the generator [Wh].
		 * - generatorFuelConsumption {number} Fuel consumed by the generator [L].
		 * - remainingLoad {number} Unmet load [Wh].
		 * - wastedSolar {number} Solar energy not used due to inefficiencies [Wh].
		 */
		GenerationSiteOperationStep operate(double t, double dt, double dcArrayOutputWhPerWp, double load) {
			double wastedSolar = 0;
			double energySentToLoad = 0;
			double generatorLoad = 0;
			double generatorFuelConsumption = 0;
			const double batteryEnergyStart = batteryBank->getEnergy();
			const double batterySOCStart = batteryBank->soc();

			// Charge the batteries from the charge controllers
			double availableDCFromCCs = std::accumulate(chargeControllers.begin(), chargeControllers.end(), 0.0, [this, dcArrayOutputWhPerWp, dt](double sum, const std::shared_ptr<ChargeController>& chargeController) {
				return sum + chargeController->getEnergy(dcArrayOutputWhPerWp, batteryBank->getOutputVoltage(), dt);
			});
			double ccSolarToBattery = batteryBank->requestCharge(availableDCFromCCs, dt);
			wastedSolar+= availableDCFromCCs - ccSolarToBattery;

			if (generator != nullptr) {
				// If the generator is on but should be off, turn it off.
				if (generator->isOn() && shouldTurnGeneratorOff(batteryBank->soc(), t)) {
					generator->turnOff();
				}
				// If the generator is off but should be on, turn it on.
				if (!generator->isOn() && shouldTurnGeneratorOn(batteryBank->soc(), t)) {
					generator->turnOn();
				}
				// If the generator is still on, use it to charge the batteries.
				// Note: this commands the generator to charge the batteries at 100% generator loading fraction.
				if (generator->isOn()) {
					GeneratorResponse generatorResponse = generator->supply(generator->getRatedPower(), dt);
					generatorLoad = generatorResponse.energy;
					generatorFuelConsumption = generatorResponse.diesel;
					batteryBank->requestCharge(generatorLoad, dt);
				}
			}

			double availableACFromPVInverters = std::accumulate(pvInverters.begin(), pvInverters.end(), 0.0, [this, dcArrayOutputWhPerWp, dt](double sum, const std::shared_ptr<PVInverter>& pvInverter) {
				return sum + pvInverter->getEnergy(dcArrayOutputWhPerWp, vac, dt);
			});

			double totalSolarToLoad = 0;
			double totalBatteryToLoad = 0;
			double totalSolarToBattery = ccSolarToBattery;

			// If the PV inverters can supply the load
			if (load <= availableACFromPVInverters) {
				// Fulfill entire load
				totalSolarToLoad+= load;
				energySentToLoad+= totalSolarToLoad;

				// Send the excess to the batteries
				double extraACFromPVInverters = availableACFromPVInverters - load;
				double energyStored = batteryInverter->requestChargeBatteries(extraACFromPVInverters, dt);
				totalSolarToBattery+= energyStored;
				wastedSolar+= extraACFromPVInverters - energyStored;	// Note: this counts energy lost due to battery inverter inefficiency as wasted solar. As of now, I don't count losses due to inverting battery DC as wasted energy.

			// If the PV inverters can't supply the load, request the remainder from the batteries
			} else {
				totalSolarToLoad+= availableACFromPVInverters;
				energySentToLoad+= totalSolarToLoad;
				totalBatteryToLoad = batteryInverter->requestAC(load-energySentToLoad, dt);
				totalSolarToBattery+= totalBatteryToLoad;
			}

		return {
			availableACFromPVInverters: availableACFromPVInverters,
			availableDCFromCCs: availableDCFromCCs,
			loadWithDxLosses: load,
			batterySOCWhStart: batteryEnergyStart,
			batterySOCStart: batterySOCStart,
			batterySOCWhEnd: batteryBank->getEnergy(),
			batterySOCEnd: batteryBank->soc(),
			totalSolarToLoad: totalSolarToLoad,
			totalSolarToBattery: totalSolarToBattery,
			totalBatteryToLoad: totalBatteryToLoad,
			totalEnergyToLoad: energySentToLoad,
			generatorLoad: generatorLoad,
			generatorFuelConsumption: generatorFuelConsumption,
			remainingLoad: load-energySentToLoad,
			wastedSolar: wastedSolar
		};
	}
};