/**
 * In this file, the units are:
 * - Energy: Wh
 * - Power: W
 * - Voltage: V
 * - Current: A
 * - Time: hr
 */

const L_PER_GAL = 4.54609
const HR_PER_DAY = 24
const DAYS_PER_YR = 365
const CUSTOMER_CSV_HEADER_ROWS = 4
const FOS_MAX_LOAD = 2
const VERBOSE = true

class Panel {
	#Pmp: number
	#Voc: number
	#Vmp: number
	#Isc: number
	#Imp: number
	#price: number
	
	/**
	 * A PV panel. All specifications given for standard operating conditions (SOC).
	 *
	 * @param {number} Pmp - Maximum power [W].
	 * @param {number} Voc - Open-circuit voltage [V].
	 * @param {number} Vmp - Maximum-power voltage [V].
	 * @param {number} Isc - Short-circuit current [A].
	 * @param {number} Imp - Maximum-power current [A].
	 * @param {number} price - Unit price of one panel [$].
	 * @constructor
	 */
	constructor(Pmp: number, Voc: number, Vmp: number, Isc: number, Imp: number, price: number) {
		this.#Pmp = Pmp
		this.#Voc = Voc
		this.#Vmp = Vmp
		this.#Isc = Isc
		this.#Imp = Imp
		this.#price = price
	}

	copy(): Panel {
		return new Panel(this.#Pmp, this.#Voc, this.#Vmp, this.#Isc, this.#Imp, this.#price)
	}

	get Pmp() { return this.#Pmp }
	get Voc() { return this.#Voc }
	get Vmp() { return this.#Vmp }
	get Isc() { return this.#Isc }
	get Imp() { return this.#Imp }
	get price() { return this.#price }
	
	/**
	 * Compute the amount of energy produced in one unit of time.
	 *
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @returns {number} Amount of energy [Wh] produced by the panel over the time interval.
	 */
	getEnergy(dcArrayOutputWhPerWp: number): number {
		var energy = dcArrayOutputWhPerWp*this.#Pmp
		console.assert(energy>=0, `Energy generated by panel ${energy} from DC Output ratio ${dcArrayOutputWhPerWp} and Pmp ${this.#Pmp} should be nonnegative.`)
		return energy
	}
}

class PVString {
	#panels: Panel[]
	#Pmp: number
	#Voc: number
	#Vmp: number
	#Isc: number
	#Imp: number
	#price: number

	/**
	 * A string of solar panels connected in series. Here, a "string" refers to a specific way to connect solar panels rather than an array of characters.
	 * 
	 * @param {Panel[]} panels - Array of solar panels connected in series into one string
	 * @constructor
	 */
	constructor(panels: Panel[]) {
		this.#panels = panels
		// TODO: check all panels equal
		
		this.#Pmp = 0
		this.#Voc = 0
		this.#Vmp = 0
		this.#price = 0
		this.#panels.forEach(panel => {
			this.#Pmp+= panel.Pmp
			this.#Voc+= panel.Voc
			this.#Vmp+= panel.Vmp
			this.#price+= panel.price
		})

		// NOTE: if you allow different panels in one string, this breaks.
		this.#Isc = this.#panels[0].Isc
		this.#Imp = this.#panels[0].Imp
	}

	copy(): PVString {
		var copiedPanels: Panel[] = this.#panels.map(panel => panel.copy())
		return new PVString(copiedPanels)
	}

	get panels() { return this.#panels }
	get Pmp() { return this.#Pmp }
	get Voc() { return this.#Voc }
	get Vmp() { return this.#Vmp }
	get Isc() { return this.#Isc }
	get Imp() { return this.#Imp }
	get price() { return this.#price }
	
	/**
	 * Compute the amount of energy produced in one unit of time by every panel in the string.
	 *
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @returns {number} Amount of energy [Wh] produced by the string over the time interval.
	 */
	getEnergy(dcArrayOutputWhPerWp: number): number {
		var energy: number = this.panels.reduce((sum, panel) => sum+panel.getEnergy(dcArrayOutputWhPerWp), 0)
		return energy
	}
}

class Subarray {
	#pvStrings: PVString[]
	#arrayLosses: number
	#Voc: number
	#Vmp: number
	#Pmp: number
	#Isc: number
	#Imp: number
	#price: number

	/**
	 * A subarray of strings of solar panles connected in parallel through a combiner box to be plugged into a PV inverter or charge controller as a PV input.
	 * 
	 * @param {PVString[]} pvStrings - Array of PVStrings to be connected in parallel through a combiner box. 
	 * @param {number} arrayLosses - Fraction of energy produced by the panels that is lost before reaching the PV inverter or charge controller
	 * @constructor
	 */
	constructor(pvStrings: PVString[], arrayLosses: number) {
		this.#pvStrings = pvStrings
		// TODO: confirm all strings same
		this.#arrayLosses = arrayLosses
		console.assert(arrayLosses>=0 && arrayLosses<=1, `Array losses ${arrayLosses} must be in [0,1]`)

		// NOTE: this breaks if strings have different voltages
		this.#Voc = this.#pvStrings[0].Voc
		this.#Vmp = this.#pvStrings[0].Vmp

		this.#Pmp = 0
		this.#Isc = 0
		this.#Imp = 0
		this.#price = 0
		this.#pvStrings.forEach(pvString => {
			this.#Pmp+= pvString.Pmp
			this.#Isc+= pvString.Isc
			this.#Imp+= pvString.Imp
			this.#price+= pvString.price
		})
	}

	copy(): Subarray {
		var copiedPVStrings: PVString[] = this.#pvStrings.map(pvString => pvString.copy())
		return new Subarray(copiedPVStrings, this.#arrayLosses)
	}

	get PVStrings() { return this.#pvStrings }
	get Voc() { return this.#Voc }
	get Vmp() { return this.#Vmp }
	get Pmp() { return this.#Pmp }
	get Isc() { return this.#Isc }
	get Imp() { return this.#Imp }
	get price() { return this.#price }
	
	/**
	 * Compute the amount of energy produced in one unit of time by the entire subarray.
	 *
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @returns {number} Amount of energy [Wh] produced by the subarray over the time interval.
	 */
	getEnergy(dcArrayOutputWhPerWp: number): number {
		var energy: number = this.#pvStrings.reduce((sum, pvString) => sum+pvString.getEnergy(dcArrayOutputWhPerWp), 0)
		return energy*(1-this.#arrayLosses)
	}
}

class PVInput {
	#Voc_min: number
	#Voc_max: number
	#Vmp_min: number
	#Vmp_max: number
	#Isc_max: number
	#Imp_max: number
	#price: number
	#subarray: Subarray

	/**
	 * An input into a PV inverter or charge controller. Is connected to exactly one PV subarray.
	 * 
	 * @param {number} Voc_min - Minimum open-circuit voltage allowed of a connected subarray. The sum of the Vocs of all the panels in a string should be greater than or equal to this value. 
	 * @param {number} Voc_max - Maximum open-circuit voltage allowed of a connected subarray.
	 * @param {number} Vmp_min - Minimum maximum-power voltage allowed of a connected subarray. 
	 * @param {number} Vmp_max - Maximum maximum-power voltage allowed of a connected subarray.
	 * @param {number} Isc_max - Maximum short-circuit current allowed of a connected subarray. The sum of the Iscs of all the strings in a subarray should be less than or equal to this value.
	 * @param {number} Imp_max - Maximum maximum-power current allowed of a connected subarray.
	 * @constructor 
	 */
	constructor(Voc_min: number, Voc_max: number, Vmp_min: number, Vmp_max: number, Isc_max: number, Imp_max: number) {
		this.#Voc_min = Voc_min
		this.#Voc_max = Voc_max
		this.#Vmp_min = Vmp_min
		this.#Vmp_max = Vmp_max
		this.#Isc_max = Isc_max
		this.#Imp_max = Imp_max
		this.#price = 0
	}

	/**
	 * Connect a single subarray of panels to this PV input. Check to make sure the subarray specs, Voc, Vmp, Isc, and Imp, are within the parameters of the PV input.
	 * 
	 * @param {Subarray} subarray - The subarray to connect to the PV input.
	 * @throws An error if any of the subarray parameters, Voc, Vmp, Isc, or Imp, are outside the acceptable bounds of this PV input.
	 */
	connectSubarray(subarray: Subarray): void {
		this.#subarray = subarray

		if (this.#subarray.Voc<this.#Voc_min || this.#subarray.Voc>this.#Voc_max) {
			throw new Error(`Subarray Voc ${this.#subarray.Voc} is outside the bounds [${this.#Voc_min},${this.#Voc_max}]`)
		}
		if (this.#subarray.Vmp<this.#Vmp_min || this.#subarray.Vmp>this.#Vmp_max) {
			throw new Error(`Subarray Vmp ${this.#subarray.Vmp} is outside the bounds [${this.#Vmp_min},${this.#Vmp_max}]`)
		}
		if (this.#subarray.Isc>this.#Isc_max) {
			throw new Error(`Subarray Isc ${this.#subarray.Isc} is greater than the charge controller Isc_max ${this.#Isc_max}`)
		}
		if (this.#subarray.Imp>this.#Imp_max) {
			throw new Error(`Subarray Imp ${this.#subarray.Imp} is greater than the charge controller Imp_max ${this.#Imp_max}`)
		}

		this.#price = this.#subarray.price
	}

	copy(): PVInput {
		var copiedSubarray: Subarray = this.#subarray.copy()
		var copiedPVInput: PVInput = new PVInput(this.#Voc_min, this.#Voc_max, this.#Vmp_min, this.#Vmp_max, this.#Isc_max, this.#Imp_max)
		copiedPVInput.connectSubarray(copiedSubarray)
		return copiedPVInput
	}

	get price() { return this.#price }
	get Pmp() { return this.#subarray.Pmp }

	/**
	 * Energy generated by the subarray connected to this PV inverter
	 * 
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @returns {number} Amount of energy [Wh] produced by the subarray connected to this PV input over the time interval.
	 */
	getEnergy(dcArrayOutputWhPerWp: number): number {
		var energy = this.#subarray.getEnergy(dcArrayOutputWhPerWp)
		return energy
	}
}

abstract class PVInverterCC {
	#pvInputs: PVInput[]
	#maxPVPower: number
	#price: number
	#subarrayPrice: number

	/**
	 * A customer archetype and quantity.
	 *
	 * @param {Array<PVInput>} pvInputs - Array of PVInputs of device.
	 * @param {number} maxPVPower - Maximum PV generator power [Wp].
	 * @param {number} price - Price of device [$].
	 * @constructor
	 */
	constructor(pvInputs: PVInput[], maxPVPower: number, price: number) {
		this.#pvInputs = pvInputs
		this.#maxPVPower = maxPVPower
		this.#price = price

		this.#subarrayPrice = 0
		var Pmp = 0
		this.#pvInputs.forEach(pvinput => {
			this.#subarrayPrice+= pvinput.price
			Pmp+= pvinput.Pmp
		})
		if (Pmp>this.#maxPVPower) {
			throw new Error(`Too much PV input power connected. ${Pmp}>${this.#maxPVPower}`)
		}
	}

	copy(): PVInverterCC {
		throw new Error('Must implement')
	}

	get PVInputs() { return this.#pvInputs }
	get maxPVPower() { return this.#maxPVPower }
	get price() { return this.#price }
	get totalPrice() { return this.#subarrayPrice + this.#price }

	/**
	 * The amount of energy [Wh] that could be generated by the attached PV if the PVInverterCC had no output power limit.
	 * 
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @returns {number}
	 */
	getUnlimitedEnergy(dcArrayOutputWhPerWp: number): number {
		var energy: number = this.#pvInputs.reduce((sum, pvInput) => sum+pvInput.getEnergy(dcArrayOutputWhPerWp), 0)
		console.assert(energy>=0, `Energy generated by PV panels connected to PVInverterCharger ${energy} must be >=0`)
		return energy
	}

	/**
	 * Energy [Wh] generated by the subarray connected to this PV inverter. In the abstract class, this will throw an error. This method must be implemented in the subclass.
	 * 
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @param {number} outputVoltage - The voltage of the output of the PV inverter or charge controller. For a PV inverter, this will be the VAC of LV in the country of operation. For a charge controller, this will be the DCV of the powerhouse.
	 * @param {number} dt - The time interval [hr]
	 * @returns {number}
	 * @throws An error if called. You must re-implement this in the subclass.
	 */
	getEnergy(dcArrayOutputWhPerWp: number, outputVoltage: number, dt: number): number {
		throw new Error('Need to implement.')
	}
}

class ChargeController extends PVInverterCC {
	#batteryChargeCurrent: number

	/**
	 * A DC-coupled power generation device.
	 * 
	 * @param {number} batteryChargeCurrent - The maximum output current of the device.
	 * @param {number} maxPVPower - The maximum Pmp of all solar panels connected to the device.
	 * @param {PVInput[]} pvInputs - Array of PV inputs of the device. Each PV input should be connected to a single subarray. 
	 * @param {number} price - The unit price of the device. 
	 */
	constructor(batteryChargeCurrent: number, maxPVPower: number, pvInputs: PVInput[], price: number) {
		super(pvInputs, maxPVPower, price)
		this.#batteryChargeCurrent = batteryChargeCurrent
	}

	copy(): ChargeController {
		var copiedPVInputs: PVInput[] = this.PVInputs.map(pvInput => pvInput.copy())
		return new ChargeController(this.#batteryChargeCurrent, this.maxPVPower, copiedPVInputs, this.price)
	}

	get batteryChargeCurrent() { return this.#batteryChargeCurrent }

	/**
	 * Energy generated by the subarrays connected to the device.
	 * 
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @param {number} outputVoltage - The DCV of the powerhouse.
	 * @param {number} dt - The time interval [hr]
	 * @returns {number} Amount of energy [Wh] output by the device over the time interval.
	 */
	getEnergy(dcArrayOutputWhPerWp: number, outputVoltage: number, dt: number): number {
		var energy = Math.min(super.getUnlimitedEnergy(dcArrayOutputWhPerWp), outputVoltage*this.#batteryChargeCurrent*dt)
		console.assert(energy>=0, `Energy produced by CC ${energy} must be >0.\nOutput Voltage=${outputVoltage}\nBattery Charge Current=${this.#batteryChargeCurrent}\ndt=${dt}\nEnergy generated by connected PV=${super.getUnlimitedEnergy(dcArrayOutputWhPerWp)}`)
		return energy
	}
}

class PVInverter extends PVInverterCC {
	#ratedPower: number

	/**
	 * An AC-coupled power generation device.
	 * 
	 * @param {number} ratedPower - The maximum output power of the device.
	 * @param {number} maxPVPower - The maximum Pmp of all solar panels connected to the device.
	 * @param {PVInput[]} pvInputs - Array of PV inputs of the device. Each PV input should be connected to a single subarray. 
	 * @param {number} price - The unit price of the device. 
	 */
	constructor(ratedPower: number, maxPVPower: number, pvInputs: PVInput[], price: number) {
		super(pvInputs, maxPVPower, price)
		this.#ratedPower = ratedPower
	}

	copy(): PVInverter {
		var copiedPVInputs: PVInput[] = this.PVInputs.map(pvInput => pvInput.copy())
		return new PVInverter(this.#ratedPower, this.maxPVPower, copiedPVInputs, this.price)
	}

	get ratedPower() { return this.#ratedPower }

	/**
	 * Energy generated by the subarrays connected to the device.
	 * 
	 * @param {number} dcArrayOutputWhPerWp - Amount of energy [Wh] a 1-Wp panel could output during the time interval.
	 * @param {number} outputVoltage - The AC voltage of the distribution network. This input is not actually used by this method.
	 * @param {number} dt - The time interval [hr]
	 * @returns {number} Amount of energy [Wh] output by the device over the time interval.
	 */
	getEnergy(dcArrayOutputWhPerWp: number, outputVoltage: number, dt: number): number {
		var energy = Math.min(super.getUnlimitedEnergy(dcArrayOutputWhPerWp), this.#ratedPower*dt)
		console.assert(energy>=0, `Energy produced by PV inverter ${energy} must be >0.\nRated power=${this.#ratedPower}\ndt=${dt}\nEnergy generated by connected PV=${super.getUnlimitedEnergy(dcArrayOutputWhPerWp)}`)
		return energy
	}
}

abstract class ACDCCoupledEquipmentGroup {
	#equipmentGroup: PVInverterCC[]

	/**
	 * Group of generation equipment, either PV inverters or charge contollers.
	 * 
	 * @param {PVInverterCC[]} equipmentGroup - Array of PV inverters or charge controllers.
	 */
	constructor(equipmentGroup: PVInverterCC[]) {
		this.#equipmentGroup = equipmentGroup
	}

	copy(): ACDCCoupledEquipmentGroup {
		throw new Error('Must implement')
	}

	get equipmentGroup() { return this.#equipmentGroup }

	/**
	 * The price of the group equipment and all connected solar panels.
	 * 
	 * @returns {number}
	 */
	get price(): number {
		return this.#equipmentGroup.reduce((sum, equipment) => sum+equipment.totalPrice, 0)
	}
}

class DCCoupledPVGenerationEquipment extends ACDCCoupledEquipmentGroup {
	#equipmentGroup: ChargeController[]

	/**
	 * Group of charge controllers.
	 * 
	 * @param {ChargeController[]} chargeControllers 
	 */
	constructor(chargeControllers: ChargeController[]) {
		super(chargeControllers)
	}

	copy(): DCCoupledPVGenerationEquipment {
		var copiedEquipmentGroup: ChargeController[] = this.#equipmentGroup.map(equipment => equipment.copy())
		return new DCCoupledPVGenerationEquipment(copiedEquipmentGroup)
	}

	/**
	 * Amount of energy 
	 * @param dcArrayOutputWhPerWp 
	 * @param outputVoltage 
	 * @param dt 
	 * @returns 
	 */
	getEnergy(dcArrayOutputWhPerWp: number, outputVoltage: number, dt: number): number {
		var energy: number = 0
		this.equipmentGroup.forEach((cc: ChargeController) => {
			energy+= cc.getEnergy(dcArrayOutputWhPerWp, outputVoltage, dt)
		})
		return energy
	}
}

class ACCoupledPVGenerationEquipment extends ACDCCoupledEquipmentGroup {
	#equipmentGroup: PVInverter[]

	constructor(pvInverters: PVInverter[]) {
		super(pvInverters)
	}

	copy(): ACCoupledPVGenerationEquipment {
		var copiedEquipmentGroup: PVInverter[] = this.#equipmentGroup.map(equipment => equipment.copy())
		return new ACCoupledPVGenerationEquipment(copiedEquipmentGroup)
	}

	getEnergy(dcArrayOutputWhPerWp: number, outputVoltage: number, dt: number): number {
		var energy: number = 0
		this.equipmentGroup.forEach((inverter: PVInverter) => {
			energy+= inverter.getEnergy(dcArrayOutputWhPerWp, outputVoltage, dt)
		})
		return energy
	}
}

class Battery {
	#capacity: number
	#minSOC: number
	#cRate: number
	#dRate: number
	#price: number

	/**
	 * One battery, to be connected into a battery bank.
	 * 
	 * @param {number} capacity - Total battery energy storage capacity [Wh]
	 * @param {number} minSOC - Minimum acceptable state of charge [0-1]
	 * @param {number} cRate - Minimum complete charge time in hours
	 * @param {number} dRate - Minimum complete discharge time in hours
	 * @param {number} price - Unit cost of battery, exclusive of shipping, clearing, labor, etc. [$]
	 */
	constructor(capacity: number, minSOC: number, cRate: number, dRate: number, price: number) {
		this.#capacity = capacity
		this.#minSOC = minSOC
		console.assert(minSOC>=0 && minSOC<=1, `MinSOC ${minSOC} must be between 0 and 1.`)
		this.#cRate = cRate
		this.#dRate = dRate
		this.#price = price
	}

	copy(): Battery {
		return new Battery(this.#capacity, this.#minSOC, this.#cRate, this.#dRate, this.#price)
	}

	get capacity() { return this.#capacity }
	get minSOC() { return this.#minSOC }
	get cRate() { return this.#cRate }
	get dRate() { return this.#dRate }
	get price() { return this.#price }
}

class BatteryBank {
	#batteries: Battery[]
	#outputVoltage: number
	#minSOC: number
	#cRate: number
	#dRate: number
	#price: number
	#capacity: number
	#energy: number
	#cumE: number

	constructor(batteries: Battery[], outputVoltage: number) {
		this.#batteries = batteries
		this.#outputVoltage = outputVoltage
		// TODO: confirm batteries are equivalent

		// NOTE: if batteries not equivalent, this breaks
		this.#minSOC = batteries[0].minSOC
		this.#cRate = batteries[0].cRate
		this.#dRate = batteries[0].dRate
		
		this.#price = 0
		this.#capacity = 0
		this.#batteries.forEach(battery => {
			this.#capacity+= battery.capacity
			this.#price+= battery.price
		})
		
		this.#energy = this.#capacity
		this.#cumE = 0
	}

	get batteries() { return this.#batteries }
	get outputVoltage() { return this.#outputVoltage }
	get minSOC() { return this.#minSOC }
	get price() { return this.#price }
	get capacity() { return this.#capacity }
	get energy() { return this.#energy }
	get effectiveEnergy(): number { return this.#energy - this.#minSOC*this.#capacity }

	// TODO: add limits for charging and discharging rates
	getEnergyAvailable(dt: number): number {
		return this.effectiveEnergy
	}

	get soc() { return this.#energy/this.#capacity }

	canDischarge(energy: number): boolean {
		return (this.#energy-energy)/this.#capacity > this.#minSOC
	}

	canCharge(energy: number): boolean {
		return (this.#energy+energy) <= this.#capacity
	}

	/**
	 * Requests energy from the batteries. Updates SOC and cycles.
	 *
	 * @param {number} energy - The amount of energy requested from the batteries [Wh].
	 * @returns {number} - The amount of energy actually supplied by the batteries, limited by the min SOC
	 */
	requestDischarge(energy: number): number {
		var energySupplied: number = Math.min(this.effectiveEnergy, energy)

		this.#energy-= energySupplied
		this.#cumE+= energySupplied

		return energySupplied
	}

	/**
	 * Requests the batteries charge using incoming energy. Updates SOC and cycles.
	 *
	 * @param {number} energy - The amount of energy requested to the batteries [Wh].
	 * @returns {number} - The amount of energy actually used to charge the batteries, limited by the capacity
	 */
	requestCharge(energy: number): number {
		var energySupplied: number = Math.min(this.#capacity-this.#energy, energy)

		this.#energy+= energySupplied
		this.#cumE+= energySupplied

		return energySupplied
	}
}

class BatteryInverter {
	#ratedPower: number
	#inverterEfficiency: number
	#chargerEfficiency: number
	#price: number
	#batteryBank: BatteryBank

	constructor(ratedPower: number, inverterEfficiency: number, chargerEfficiency: number, price: number) {
		this.#ratedPower = ratedPower
		this.#inverterEfficiency = inverterEfficiency
		this.#chargerEfficiency = chargerEfficiency
		this.#price = price
	}

	get ratedPower() { return this.#ratedPower }
	get inverterEfficiency() { return this.#inverterEfficiency }
	get chargerEfficiency() { return this.#chargerEfficiency }
	get price() { return this.#price }

	/**
	 * Requests energy from the batteries inverted into AC. Updates SOC and cycles.
	 *
	 * @param {number} ac - The amount of energy requested to the AC bus [Wh].
	 * @param {number} dt - The amount of time to provide the energy [hr]
	 * @returns {number} - The amount of AC actually produced, limited by the power rating and the batteries [Wh]
	 */
	requestAC(ac: number, dt: number): number {
		if (!this.#batteryBank) {
			throw new Error('Battery inverter needs battery bank to invert.')
		}
		
		// Limit AC ouptut by rated power
		ac = Math.min(ac, this.ratedPower*dt)

		// Amount of DC needed to fulfill the load [Wh]
		var dcNeeded: number = ac/this.inverterEfficiency

		// Amount of DC drawn from the batteries [Wh]
		var dcProduced: number = this.#batteryBank.requestDischarge(dcNeeded)

		// Amount of AC actually provided
		return dcProduced*this.inverterEfficiency
	}

	/**
	 * Requests excess energy to be used to charge the batteries. Updates SOC and cycles.
	 *
	 * @param {number} ac - The amount of AC energy to send to the batteries [Wh].
	 * @param {number} dt - The amount of time to send the energy [hr]
	 * @returns {number} - The amount of DC energy actually stored in the batteries, limited by the power rating and the batteries [Wh]
	 */
	requestChargeBatteries(ac: number, dt: number): number {
		if (!this.#batteryBank) {
			throw new Error('Battery inverter needs a battery bank to charge.')
		}

		// Limit DC output by rated power
		ac = Math.min(ac, this.ratedPower*dt)

		// Rectify AC into DC
		var dcProduced: number = ac*this.chargerEfficiency

		// Charge batteries with DC
		return this.#batteryBank.requestCharge(dcProduced)
	}

	connectBatteryBank(batteryBank: BatteryBank): void {
		this.#batteryBank = batteryBank
	}

	canSupply(energy: number, time: number): boolean {
		return energy/time<=this.ratedPower
	}

	toString() {
		return `${this.#ratedPower} battery inverter costing ${this.#price}`
	}
}

interface GeneratorResponse {
	energy: number
	diesel: number
}

class DieselGenerator {
	#ratedPower: number
	#price: number
	#runHours: number
	#dieselConsumed: number
	#turnedOn: boolean
	#currentOutput: number
	#generatorRow: number[]

	constructor(ratedPower: number, price: number) {
		this.#ratedPower = ratedPower
		this.#price = price

		this.#runHours = 0
		this.#dieselConsumed = 0
		this.#turnedOn = false
		this.#currentOutput = 0

		if (this.#ratedPower < Math.min(...DieselGenerator.genSizeHeaders) || this.#ratedPower>Math.max(...DieselGenerator.genSizeHeaders)) {
			throw new Error(`Diesel genset power ${this.#ratedPower} is outside the range [${Math.min(...DieselGenerator.genSizeHeaders),Math.max(...DieselGenerator.genSizeHeaders)}].`)
		}
		this.#generatorRow = []
		for (let p: number=0; p<DieselGenerator.genSizeHeaders.length; p++) {
			if (this.#ratedPower === DieselGenerator.genSizeHeaders[p]) {
				this.#generatorRow = DieselGenerator.generatorTable[p]
				break
			} else if (this.#ratedPower < DieselGenerator.genSizeHeaders[p+1]) {
				var p_frac: number = (this.#ratedPower-DieselGenerator.genSizeHeaders[p])/(DieselGenerator.genSizeHeaders[p+1]-DieselGenerator.genSizeHeaders[p])
				for (let l: number=0; l<DieselGenerator.loadingFracHeaders.length; l++) {
					this.#generatorRow.push(DieselGenerator.generatorTable[p][l] + p_frac*(DieselGenerator.generatorTable[p+1][l]-DieselGenerator.generatorTable[p][l]))
				}
				break
			}
		}
	}

	get ratedPower() { return this.#ratedPower }
	get price() { return this.#price }
	get runHours() { return this.#runHours }
	get dieselConsumed() { return this.#dieselConsumed }
	get currentOutput() { return this.#currentOutput }

	static get generatorTable(): number[][] {
		return [
			[0.0,  0.3,  0.5,   0.7,   0.8],
			[0.0,  0.6,  0.9,   1.3,   1.6],
			[0.0,  1.3,  1.8,   2.4,   2.9],
			[0.0,  1.6,  2.3,   3.2,   4.0],
			[0.0,  1.8,  2.9,   3.8,   4.8],
			[0.0,  2.4,  3.4,   4.6,   6.1],
			[0.0,  2.6,  4.1,   5.8,   7.4],
			[0.0,  3.1,  5.0,   7.1,   9.1],
			[0.0,  3.3,  5.4,   7.6,   9.8],
			[0.0,  3.6,  5.9,   8.4,  10.9],
			[0.0,  4.1,  6.8,   9.7,  12.7],
			[0.0,  4.7,  7.7,  11.0,  14.4],
			[0.0,  5.3,  8.8,  12.5,  16.6],
			[0.0,  5.7,  9.5,  13.6,  18.0],
			[0.0,  6.8, 11.3,  16.1,  21.5],
			[0.0,  7.9, 13.1,  18.7,  25.1],
			[0.0,  8.9, 14.9,  21.3,  28.6],
			[0.0, 11.0, 18.5,  26.4,  35.7],
			[0.0, 13.2, 22.0,  31.5,  42.8],
			[0.0, 16.3, 27.4,  39.3,  53.4],
			[0.0, 21.6, 36.4,  52.1,  71.1],
			[0.0, 26.9, 45.3,  65.0,  88.8],
			[0.0, 32.2, 54.3,  77.8, 106.5],
			[0.0, 37.5, 63.2,  90.7, 124.2],
			[0.0, 42.8, 72.2, 103.5, 141.9],
			[0.0, 48.1, 81.1, 116.4, 159.6]
		]
	}

	static get loadingFracHeaders(): number[] {
		return [0, 0.25, 0.5, 0.75, 1.0]
	}

	static get genSizeHeaders(): number[] {
		return [10, 20, 30, 40, 60, 75, 100, 125, 135, 150, 175, 200, 230, 250, 300, 350, 400, 500, 600, 750, 1000, 125, 1500, 1750, 2000, 2250]
	}

	canSupply(energy: number, time: number) {
		return energy/time<=this.ratedPower
	}

	get isOn(): boolean {
		return this.#turnedOn
	}

	turnOn(): void {
		this.#turnedOn = true
	}
	turnOff(): void {
		this.#turnedOn = false
	}

	/**
	 * Request generator supply power. Updates diesel consumption, run hours, and current output.
	 *
	 * @param {number} power - Amount of power requested from the generator.
	 * @param {number} dt - Amount of time to run.
	 * @returns {Object} - An object with two keys:
	 * - energy {number} Amount of energy supplied during dt.
	 * - diesel {number} Amount of diesel consumed during dt.
	 */
	supply(power: number, dt: number): GeneratorResponse {
		var loadingFrac: number = power/this.ratedPower
		if (loadingFrac > Math.max(...DieselGenerator.loadingFracHeaders)) {
			console.warn(`Generator asked to supply ${power}, but can only supply ${this.ratedPower}`)
			power = this.ratedPower
			loadingFrac = 1.0
		}

		var galPerHr: number = -1
		for (let l: number=0; l<DieselGenerator.loadingFracHeaders.length; l++) {
			if (loadingFrac === DieselGenerator.loadingFracHeaders[l]) {
				galPerHr = this.#generatorRow[l]
			} else if (loadingFrac < DieselGenerator.loadingFracHeaders[l+1]) {
				var l_frac: number = (loadingFrac - DieselGenerator.loadingFracHeaders[l]) / (DieselGenerator.loadingFracHeaders[l+1] - DieselGenerator.loadingFracHeaders[l])
				galPerHr = this.#generatorRow[l] + l_frac*(this.#generatorRow[l+1] - this.#generatorRow[l])
			}
		}
		if (galPerHr === -1) {
			throw new Error(`I wasn't able to compute the amount of diesel consumed per hour.`)
		}
		var lPerHr: number = galPerHr*L_PER_GAL

		this.#dieselConsumed+= lPerHr*dt
		this.#runHours+= dt
		this.#currentOutput = power
		return {
			energy: power*dt,
			diesel: lPerHr*dt
		}
	}
}

class Customer {
	#name: string
	#maxLoad: number
	#loadProfile: (tariff: number, t: number) => number
	#qty: number

	/**
	 * A customer archetype and quantity.
	 *
	 * @param {string} name - Unique name for the class of customer, e.g. "residential" or "commercial"
	 * @param {number} maxLoad - Maximum instantaneous load of a single customer [W]
	 * @param {(tariff: number, t: number) => number} loadProfile - Energy needs of a single customer [Wh/hr] given the tariff and time since commissioning [hr].
	 * @param {number} qty - Quantity of customers of that archetype.
	 * @constructor
	 */
	constructor(name: string, maxLoad: number, loadProfile: (tariff: number, t: number) => number, qty: number) {
		this.#name = name
		this.#maxLoad = maxLoad
		this.#loadProfile = loadProfile
		this.#qty = qty
	}

	get name() { return this.#name }
	get maxLoad() { return this.#maxLoad }
	get totalMaxLoad() { return this.#maxLoad*this.#qty }
	get loadProfile() { return this.#loadProfile }
	get totalLoadProfile() {
		return (tariff: number, t: number) => this.loadProfile(tariff, t)*this.#qty
	}

	get qty () { return this.#qty }

	getLoad(tariff: number, t: number): number {
		return this.#loadProfile(tariff, t)
	}

	getTotalLoad(tariff: number, t: number): number {
		return this.totalLoadProfile(tariff, t)
	}
}

interface GenerationSiteOperationStep {
	availableACFromPVInverters: number
	availableDCFromCCs: number
	loadWithDxLosses: number
	batterySOCWhStart: number
	batterySOCStart: number
	batterySOCWhEnd: number
	batterySOCEnd: number
	totalSolarToLoad: number
	totalSolarToBattery: number
	totalBatteryToLoad: number
	totalEnergyToLoad: number
	generatorLoad: number
	generatorFuelConsumption: number
	remainingLoad: number
	wastedSolar: number
}

class GenerationSite {
	#batteryInverter: BatteryInverter
	#batteryBank: BatteryBank
	#pvInverters: ACCoupledPVGenerationEquipment
	#chargeControllers: DCCoupledPVGenerationEquipment
	#generator: DieselGenerator | null
	#shouldTurnGeneratorOn: (soc: number, t: number) => boolean
	#shouldTurnGeneratorOff: (soc: number, t: number) => boolean
	#vac: number
	#acBus: number

	/**
	 * All of the equipment at a generation site.
	 *
	 * @param {BatteryInverter} batteryInverter - The total battery inverter.
	 * @param {BatteryBank} batteryBank - The battery bank.
	 * @param {ACCoupledPVGenerationEquipment} pvInverters - All of the PV inverters and their connected solar panels.
	 * @param {DCCoupledPVGenerationEquipment} chargeControllers - All of the charge controllers and their connected solar panels
	 * @param {Generator} generator - The diesel generator
	 * @param {function(soc: number, t: number) => boolean} shouldTurnOnGenerator - A function to decide when to turn the generator on given battery SOC and the current time since commissioning [hr]
	 * @param {function(soc: number, t: number) => boolean} shouldTurnOffGenerator - A function to decide when to turn the generator off given battery SOC and the current time since commissioning [hr]
	 * @param {number} vac - Output AC voltage
	 * @constructor
	 */
	constructor(
		batteryInverter: BatteryInverter,
		batteryBank: BatteryBank,
		pvInverters: ACCoupledPVGenerationEquipment,
		chargeControllers: DCCoupledPVGenerationEquipment,
		generator: DieselGenerator | null,
		shouldTurnGeneratorOn: (soc: number, t: number) => boolean = (soc: number, t: number) => false,
		shouldTurnGeneratorOff: (soc: number, t: number) => boolean = (soc: number, t: number) => false,
		vac: number)
	{
		this.#batteryInverter = batteryInverter
		this.#batteryBank = batteryBank
		this.#pvInverters = pvInverters
		this.#chargeControllers = chargeControllers
		this.#generator = generator
		this.#shouldTurnGeneratorOn = shouldTurnGeneratorOn
		this.#shouldTurnGeneratorOff = shouldTurnGeneratorOff
		this.#vac = vac
	
		this.#batteryInverter.connectBatteryBank(this.#batteryBank)
		this.#acBus = 0
	}

	get batteryInverter() { return this.#batteryInverter }
	get batteryBank() { return this.#batteryBank }
	get pvInverters() { return this.#pvInverters }
	get chargeControllers () { return this.#chargeControllers }
	get generator() { return this.#generator }

	/**
	 * Runs the generation site for one unit of time
	 *
	 * @param {number} t - Time since commissioning [hr]
	 * @param {number} dt - The amount of time that passes [hr].
	 * @param {number} dcArrayOutputWhPerWp - From irradiance data [Wh/kWp].
	 * @param {number} load - Total load, including distribution losses [Wh].
	 * @returns {Object} - An object with 13 keys:
	 * - availableACFromPVInverters {number} Energy generated by PV inverters [Wh].
	 * - availableDCFromCCs {number} Energy generated by charge controllers [Wh].
	 * - loadWithDxLosses {number} The load, given as an input parameter [Wh].
	 * - batterySOCWhStart {number} Amount of energy remaining in the battery bank at the start of dt [Wh].
	 * - batterySOCStart {number} SOC of the battery bank at the start of dt.
	 * - batterySOCWhEnd {number} Amount of energy remaining in the battery bank at the end of dt [Wh].
	 * - batterySOCEnd {number} SOC of the battery bank at the end of dt.
	 * - totalSolarToLoad {number} Energy sent from the PV inverters to the load [Wh].
	 * - totalSolarToBattery {number} Energy sent from the PV to the batteries [Wh].
	 * - totalBatteryToLoad {number} Energy sent from the batteries to the load [Wh].
	 * - totalEnergyToLoad {number} Energy sent from the generation site to the load [Wh].
	 * - generatorLoad {number} Energy supplied by the generator [Wh].
	 * - generatorFuelConsumption {number} Fuel consumed by the generator [L].
	 * - remainingLoad {number} Unmet load [Wh].
	 * - wastedSolar {number} Solar energy not used due to inefficiencies [Wh].
	 */
	operate(t: number, dt: number, dcArrayOutputWhPerWp: number, load: number): GenerationSiteOperationStep {
		var wastedSolar = 0
		var energySentToLoad = 0
		var generatorLoad = 0
		var generatorFuelConsumption = 0
		const batteryEnergyStart = this.batteryBank.energy
		const batterySOCStart = this.batteryBank.soc

		// Charge the batteries from the charge controllers
		var availableDCFromCCs: number = this.chargeControllers.getEnergy(dcArrayOutputWhPerWp, this.batteryBank.outputVoltage, dt)
		var ccSolarToBattery: number = this.batteryBank.requestCharge(availableDCFromCCs)
		wastedSolar+= availableDCFromCCs - ccSolarToBattery

		if (this.generator !== null) {
			// If the generator is on but should be off, turn it off.
			if (this.generator.isOn && this.#shouldTurnGeneratorOff(this.batteryBank.soc, t)) {
				this.generator.turnOff()
			}
			// If the generator is off but should be on, turn it on.
			if (!this.generator.isOn && this.#shouldTurnGeneratorOn(this.batteryBank.soc, t)) {
				this.generator.turnOn()
			}
			// If the generator is still on, use it to charge the batteries.
			// Note: this commands the generator to charge the batteries at 100% generator loading fraction.
			if (this.generator.isOn) {
				let generatorResponse: GeneratorResponse = this.generator.supply(this.generator.ratedPower, dt)
				generatorLoad = generatorResponse.energy
				generatorFuelConsumption = generatorResponse.diesel
				this.#batteryInverter.requestChargeBatteries(generatorLoad, dt)
			}
		}

		var availableACFromPVInverters: number = this.pvInverters.getEnergy(dcArrayOutputWhPerWp, this.#vac, dt)

		var totalSolarToLoad: number = 0
		var totalBatteryToLoad: number = 0
		var totalSolarToBattery: number = ccSolarToBattery
		
		// If the PV inverters can supply the load
		if (load <= availableACFromPVInverters) {
			// Fulfill entire load
			totalSolarToLoad+= load
			energySentToLoad+= totalSolarToLoad

			// Send the excess to the batteries
			var extraACFromPVInverters: number = availableACFromPVInverters - load
			var energyStored: number = this.batteryInverter.requestChargeBatteries(extraACFromPVInverters, dt)
			totalSolarToBattery+= energyStored
			wastedSolar+= extraACFromPVInverters - energyStored	// Note: this counts energy lost due to battery inverter inefficiency as wasted solar. As of now, I don't count losses due to inverting battery DC as wasted energy.

		// If the PV inverters can't supply the load, request the remainder from the batteries
		} else {
			totalSolarToLoad+= availableACFromPVInverters
			energySentToLoad+= totalSolarToLoad
			totalBatteryToLoad = this.batteryInverter.requestAC(load-energySentToLoad, dt)
			energySentToLoad+= totalBatteryToLoad
		}

		return {
			availableACFromPVInverters: availableACFromPVInverters,
			availableDCFromCCs: availableDCFromCCs,
			loadWithDxLosses: load,
			batterySOCWhStart: batteryEnergyStart,
			batterySOCStart: batterySOCStart,
			batterySOCWhEnd: this.batteryBank.energy,
			batterySOCEnd: this.batteryBank.soc,
			totalSolarToLoad: totalSolarToLoad,
			totalSolarToBattery: totalSolarToBattery,
			totalBatteryToLoad: totalBatteryToLoad,
			totalEnergyToLoad: energySentToLoad,
			generatorLoad: generatorLoad,
			generatorFuelConsumption: generatorFuelConsumption,
			remainingLoad: load-energySentToLoad,
			wastedSolar: wastedSolar
		}
	}
}

interface MiniGridOperationStep extends GenerationSiteOperationStep {
	load: number
	remainingLoadWithDxLosses: number
	remainingLoad: number
}

class MiniGrid {
	#customers: Customer[]
	#tariff: (name: string, t: number) => number
	#dxLosses: number
	#dcArrayOutputWhPerWpFn: (t: number) => number
	#generationSite: GenerationSite

	constructor(customers: Customer[], tariff: (name: string, t: number) => number, dxLosses: number) {
		this.#customers = customers
		this.#tariff = tariff
		this.#dxLosses = dxLosses
	}

	get customers() { return this.#customers }
	get tariff() { return this.#tariff }
	get dxLosses() { return this.#dxLosses }
	get dcArrayOutputWhPerWpFn() { return this.#dcArrayOutputWhPerWpFn }
	get generationSite() { return this.#generationSite }

	place(latitude: number, longitude: number, roofMounted: boolean = false, PVWATTS_API_KEY: string) {
		const url: string = `https://developer.nrel.gov/api/pvwatts/v8.json?api_key=${PVWATTS_API_KEY}&lat=${latitude}&lon=${longitude}&system_capacity=1&module_type=0&losses=0&array_type=${roofMounted ? 1 : 0}&tilt=10&azimuth=180&timeframe=hourly&dataset=intl`

		return new Promise((resolve, reject) => {
			const request: XMLHttpRequest = new XMLHttpRequest()
			request.open('GET', url)
			request.onload = () => {
				if (request.status === 200) {
					var dcArrayOutputWhPerkWpArr: number[] = [...JSON.parse(request.response).outputs.dc]
					var dcArrayOutputWhPerWpArr: number[] = dcArrayOutputWhPerkWpArr.map(dcArrayOutputWhPerkWp => dcArrayOutputWhPerkWp/1000)
					this.#dcArrayOutputWhPerWpFn = t => dcArrayOutputWhPerWpArr[Math.round(t) % (HR_PER_DAY*DAYS_PER_YR)]
					resolve(JSON.parse(request.response))
				} else {
					reject(Error(request.statusText))
				}
			}
			request.onerror = () => {
				reject(Error('Network Error'))
			}
			request.send()
		})
	}

	buildGenerationSite(generationSite) {
		this.#generationSite = generationSite
	}

	getDCArrayOutputWhPerkWp(t: number) {
		return this.#dcArrayOutputWhPerWpFn(t)
	}

	operate(t: number, dt: number): MiniGridOperationStep {
		var dcArrayOutputWhPerWp: number = this.getDCArrayOutputWhPerkWp(t)

		var load: number = 0
		this.#customers.forEach(customer => {
			load+= customer.getTotalLoad(this.#tariff(customer.name, t), t)
		})

		var result: GenerationSiteOperationStep = this.#generationSite.operate(t, dt, dcArrayOutputWhPerWp, load/(1-this.#dxLosses))
		return {
			availableACFromPVInverters: result.availableACFromPVInverters,
			availableDCFromCCs: result.availableDCFromCCs,
			loadWithDxLosses: result.loadWithDxLosses,
			batterySOCWhStart: result.batterySOCWhStart,
			batterySOCStart: result.batterySOCStart,
			batterySOCWhEnd: result.batterySOCWhEnd,
			batterySOCEnd: result.batterySOCEnd,
			totalSolarToLoad: result.totalSolarToLoad,
			totalSolarToBattery: result.totalSolarToBattery,
			totalBatteryToLoad: result.totalBatteryToLoad,
			totalEnergyToLoad: result.totalEnergyToLoad,
			generatorLoad: result.generatorLoad,
			generatorFuelConsumption: result.generatorFuelConsumption,
			wastedSolar: result.wastedSolar,
			load: load,
			remainingLoadWithDxLosses: result.remainingLoad,
			remainingLoad: load-result.totalEnergyToLoad*(1-this.#dxLosses)
		}
	}
}

interface Credentials {
	PVWATTS_API_KEY: string
}

interface BudgetLineItem {
	category: string
	type: string
	item: string
	vendor: string
	notes: string
	currency: string
	qty: number
	price: number
	budgetVAT: boolean
	budgetTotal: number
}

class Budget {
	#exchangeRateToUSD: number
	#vatRate: number
	#lineItems: BudgetLineItem[]

	constructor(exhangeRateToUSD: number, vatRate: number) {
		this.#exchangeRateToUSD = exhangeRateToUSD
		this.#vatRate = vatRate
		this.#lineItems = []
	}

	addLineItem(category: string, type: string, item: string, vendor: string, notes: string, currency: string, qty: number, price: number, budgetVAT: boolean) {
		this.#lineItems.push({
			category: category,
			type: type,
			item: item,
			vendor: vendor,
			notes: notes,
			currency: currency,
			qty: qty,
			price: price,
			budgetVAT: budgetVAT,
			budgetTotal: (currency==='USD' ? 1 : this.#exchangeRateToUSD)*(budgetVAT ? 1+this.#vatRate : 0)*qty*price
		})
	}

	getLineItem(i) {
		return this.#lineItems[i]
	}

	getBudgetTotal() {
		return this.#lineItems.reduce((sum, lineItem) => sum+lineItem.budgetTotal, 0)
	}
}

async function run() {
	console.time('setup')
	// Get credentials
	var creds: Credentials
	const loadCredFile = new Promise((resolve, reject) => {
		const credFileInput = <HTMLInputElement> document.getElementById('cred-file')
		const credsFR = new FileReader()
		credsFR.onload = (e: Event) => {
			const contents: string = credsFR.result as string
			creds = JSON.parse(contents)
			resolve(null)
		}
		credsFR.readAsText(credFileInput.files[0])
	})
	await loadCredFile

	// Get customers
	var customers: Customer[] = []
	var defaultTariffs: number[]
	const loadCustomerFile = new Promise((resolve, reject) => {
		const custFileInput = <HTMLInputElement> document.getElementById('cust-file')
		const custFR = new FileReader()
		custFR.onload = (e:Event) => {
			const contents: string = custFR.result as string
			const rows: string[] = contents.split('\r\n')
			const custTypes: string[] = rows[0].split(',').slice(1)
			defaultTariffs = new Array(custTypes.length)
			
			// For each customer
			for (let c:number =0; c<custTypes.length; c++) {
				var loadProfileArr: { (tariff: number): number }[] = new Array(HR_PER_DAY*DAYS_PER_YR)

				// Iterate through each hour of the year
				for (let t=0; t<HR_PER_DAY*DAYS_PER_YR; t++) {
					const load: string = rows[t+CUSTOMER_CSV_HEADER_ROWS].split(',')[c+1]
					if (isNaN(Number(load))) {
						// TODO tariff optimization
						reject('Tariff optimization not yet supported')
					} else {
						loadProfileArr[t] = (tariff: number) => Number(load)*1000
					}
				}

				// Construct new customer profile and add to the array
				customers.push(new Customer(
					custTypes[c],
					Number(rows[1].split(',')[c+1]),
					(tariff: number, t: number) => loadProfileArr[Math.round(t)](tariff),
					Number(rows[2].split(',')[c+1])))
				defaultTariffs[c] = Number(rows[3].split(',')[c+1])
			}

			resolve(null)
		}
		custFR.readAsText(custFileInput.files[0])
	})
	await loadCustomerFile

	// Initialize Mini-Grid
	const latitude = Number((<HTMLInputElement>document.getElementById('location_lat')).value)	// [°N]
	const longitude = Number((<HTMLInputElement>document.getElementById('location_lon')).value)	// [°E]
	var minigrid: MiniGrid = new MiniGrid(customers, (name, t) => 1, 0.1)
	await minigrid.place(latitude, longitude, false, creds.PVWATTS_API_KEY)

	// Construct panel
	const pvPmp = Number((<HTMLInputElement>document.getElementById('pv_Pmp')).value)	// [Wp]
	var panel: Panel = new Panel(
		pvPmp,
		Number((<HTMLInputElement>document.getElementById('pv_Voc')).value),
		Number((<HTMLInputElement>document.getElementById('pv_Vmp')).value),
		Number((<HTMLInputElement>document.getElementById('pv_Isc')).value),
		Number((<HTMLInputElement>document.getElementById('pv_Imp')).value),
		pvPmp*Number((<HTMLInputElement>document.getElementById('pv_price')).value))

	// Charge controller: assemble panels into string
	var ccPanels: Panel[] = []
	const panelsPerStringCC = 3 // TODO: autostringing
	for (let p: number =0; p<panelsPerStringCC; p++) {
		ccPanels.push(panel.copy())
	}

	// Charge controller: assemble strings into subarray
	var pvString: PVString = new PVString(ccPanels)
	var ccStrings: PVString[] = []
	const stringsPerSubarrayCC = 3 // TODO: autostringing
	for (let s: number =0; s<stringsPerSubarrayCC; s++) {
		ccStrings.push(pvString.copy())
	}
	const arrayLosses = Number((<HTMLInputElement>document.getElementById('overview_array-losses')).value)/100	//[0-1]
	var ccSubarray: Subarray = new Subarray(ccStrings, arrayLosses)

	// Charge controller: connect subarray to PV input
	var ccPVInputs: PVInput[] = []
	const ccInTable = <HTMLTableElement>document.getElementById('ccs_charge-controller-inputs')
	for (let r=1; r<ccInTable.rows.length-1; r++) {
		const cells = ccInTable.rows.item(r).cells
		ccPVInputs.push(new PVInput(
			Number(cells[1].innerHTML),	// [V]
			Number(cells[2].innerHTML),	// [V]
			Number(cells[3].innerHTML),	// [V]
			Number(cells[4].innerHTML),	// [V]
			Number(cells[5].innerHTML),	// [A]
			Number(cells[6].innerHTML)	// [A]
		))
	}
	ccPVInputs[0].connectSubarray(ccSubarray)// TODO: add support for multiple PV inputs. Needs auto stringing

	// PV inverters: assemble panels into string
	var pvinvPanels: Panel[] = []
	const panelsPerStringPVInv = 19 // TODO: autostringing
	for (let p: number =0; p<panelsPerStringPVInv; p++) {
		pvinvPanels.push(panel.copy())
	}

	// PV inverters: assemble strings into subarray
	pvString = new PVString(pvinvPanels)
	var pvinvStrings: PVString[] = []
	const stringsPerSubarrayPVInv = 4 // TODO: autostringing
	for (let s: number =0; s<stringsPerSubarrayPVInv; s++) {
		pvinvStrings.push(pvString.copy())
	}
	var pvinvSubarray: Subarray = new Subarray(pvinvStrings, arrayLosses)

	// PV inverters: connect subarray to PV input
	var pvinvPVInputs: PVInput[] = []
	const pvinvInTable = <HTMLTableElement> document.getElementById('pvinv_pv-inverter-inputs')
	for (let r=1; r<pvinvInTable.rows.length-1; r++) {
		const cells = pvinvInTable.rows.item(r).cells
		pvinvPVInputs.push(new PVInput(
			Number(cells[1].innerHTML),	// [V]
			Number(cells[2].innerHTML),	// [V]
			Number(cells[3].innerHTML),	// [V]
			Number(cells[4].innerHTML),	// [V]
			Number(cells[5].innerHTML),	// [A]
			Number(cells[6].innerHTML)	// [A]
		))
	}
	pvinvPVInputs[0].connectSubarray(pvinvSubarray)// TODO: add support for multiple PV inputs. Needs auto stringing

	// Battery inverters
	var indivBattInvs: BatteryInverter[] = []
	var battInvMaxQtys: number[] = []
	const battInvTable = <HTMLTableElement> document.getElementById('batt-inv_options')
	for (let r=1; r<battInvTable.rows.length-1; r++) {
		const cells = battInvTable.rows.item(r).cells
		indivBattInvs.push(new BatteryInverter(
			Number(cells[3].innerHTML),	// [W]
			Number(cells[5].innerHTML)/100,	// [0-1]
			Number(cells[4].innerHTML)/100,	// [0-1]
			Number(cells[2].innerHTML)	// [$]
		))
		battInvMaxQtys.push(Number(cells[6].innerHTML))
	}
	var battInvs: BatteryInverter[] = []
	var battInvSizes: number[] = []
	var battInvPrices: number[] = []
	for (let b=0; b<indivBattInvs.length; b++) {
		for (let qty=1; qty<=battInvMaxQtys[b]; qty++) {
			let battInv = new BatteryInverter(
				indivBattInvs[b].ratedPower*qty,	// [W]
				indivBattInvs[b].inverterEfficiency,	// [0-1]
				indivBattInvs[b].chargerEfficiency,	// [0-1]
				indivBattInvs[b].price*qty	// [$]
			)
			let i = battInvSizes.indexOf(battInv.ratedPower)
			if (i == -1) {	// if there is no battery inverter combination of that size yet, add it
				let low = 0
				let high = battInvSizes.length

				while (low < high) {
					let mid = (low + high) >>> 1;
					if (battInvSizes[mid] < battInv.ratedPower) low = mid + 1;
					else high = mid;
				}
				battInvs.splice(low, 0, battInv)
				battInvPrices.splice(low, 0, battInv.price)
				battInvSizes.splice(low, 0, battInv.ratedPower)
			} else {	// if there is already a battery inverter combination of that size, replace it iff cheaper
				if (battInvPrices[i]>battInv.price) {
					battInvs[i] = battInv
					battInvPrices[i] = battInv.price
				}
			}
		}
	}

	// Other constants from form
	const ccBatteryChargeCurrent = Number((<HTMLInputElement>document.getElementById('ccs_max-output-current')).value)	// [A]
	const ccMaxPVPower = Number((<HTMLInputElement>document.getElementById('ccs_max-pv-power')).value)	// [Wp]
	const ccPrice = Number((<HTMLInputElement>document.getElementById('ccs_price')).value)	// [$]
	const vac = Number((<HTMLInputElement>document.getElementById('overview_vac')).value)	// [V]
	const pvinvRatedPower = Number((<HTMLInputElement>document.getElementById('pvinv_max-output-power')).value)		// [VA]
	const pvinvMaxPVPower = Number((<HTMLInputElement>document.getElementById('pvinv_max-pv-power')).value)	// [Wp]
	const pvinvPrice = Number((<HTMLInputElement>document.getElementById('pvinv_price')).value)	// [$]
	const battCapacity = Number((<HTMLInputElement>document.getElementById('batt_capacity')).value)*1000	// [Wh]
	const minSOC = Number((<HTMLInputElement>document.getElementById('batt_minSOC')).value)/100	// [0-1]
	const cRate = Number((<HTMLInputElement>document.getElementById('batt_c-rate')).value)	// [C]
	const battPrice = Number((<HTMLInputElement>document.getElementById('batt_price')).value)	// [$]
	const battDCV = Number((<HTMLInputElement>document.getElementById('batt_dcv')).value)	// [V]
	const dxLosses = Number((<HTMLInputElement>document.getElementById('dx_losses')).value)/100	// [0-1]
	const exchangeRate = Number((<HTMLInputElement>document.getElementById('misc_toUSD')).value)	// [¤/$]
	const vat = Number((<HTMLInputElement>document.getElementById('misc_vat')).value)/100	// [0-1]

	// Assemble decision variables
	var decisionVariables = {
		numChargeControllers: { value: 1, step: 1 },
		numPVInverters: { value: 1, step: 1 },
		numBatteries: { value: 1, step: 1 }
	}
	for (let c=0; c<customers.length; c++) {
		decisionVariables[`tariff${c}`] = defaultTariffs[c]
	}
	console.timeEnd('setup')
	console.time('opt')
	while (true) {
		// Construct charge controllers
		var cc: ChargeController = new ChargeController(ccBatteryChargeCurrent, ccMaxPVPower, ccPVInputs, ccPrice)
		var ccs: ChargeController[] = []
		for (let c=0; c<decisionVariables.numChargeControllers.value; c++) {
			ccs.push(cc.copy())
		}
		var ccGroup: DCCoupledPVGenerationEquipment = new DCCoupledPVGenerationEquipment(ccs)

		// Construct PV inverters
		var pvinv: PVInverter = new PVInverter(pvinvRatedPower, pvinvMaxPVPower, pvinvPVInputs, pvinvPrice)
		var pvInvs: PVInverter[] = []
		for (let p=0; p<decisionVariables.numPVInverters.value; p++) {
			pvInvs.push(pvinv.copy())
		}
		var pvInvGroup: ACCoupledPVGenerationEquipment = new ACCoupledPVGenerationEquipment(pvInvs)

		// Construct battery bank
		var batt = new Battery(battCapacity, minSOC, cRate, cRate, battPrice)
		var batteries: Battery[] = []
		for (let b=0; b<decisionVariables.numBatteries.value; b++) {
			batteries.push(batt.copy())
		}
		var batteryBank: BatteryBank = new BatteryBank(batteries, battDCV)

		// Pick battery inverter to handle max load
		var maxLoad = customers.reduce((sum, customer) => customer.totalMaxLoad + sum, 0)/(1-dxLosses)*FOS_MAX_LOAD
		var battInv: BatteryInverter
		for (let newBattInv of battInvs) {
			if (newBattInv.ratedPower>=maxLoad) {
				battInv = newBattInv
				break
			}
		}
		if (typeof battInv === 'undefined') {
			throw new Error('No battery inverter is big enough')
		}

		// TODO: Genset optimization

		// Build generation site
		var site: GenerationSite = new GenerationSite(battInv, batteryBank, pvInvGroup, ccGroup, null, null, null, vac)
		minigrid.buildGenerationSite(site)

		// TODO: Simulate
		for (let t=0; t<HR_PER_DAY*DAYS_PER_YR; t++){
			minigrid.operate(t, 1)
		}

		// TODO: Create BOQ
		var boq = new Budget(exchangeRate, vat)
		boq.addLineItem('Batteries', 'Customs', 'Clearing Agent Fees', 'Spedag', '', 'NGN', 1, 27400, true)
		// XXX: HERE

		// TODO: Compute IRR

		// Move in the direction of steepest IRR ascent

		break	// TODO: remove. I just added this so it wouldn't hang during testing.
	}
	console.timeEnd('opt')
}

document.getElementById('run').addEventListener('click', run)